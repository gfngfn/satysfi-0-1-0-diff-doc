use package open Stdlib.Logo
use package open StdJaReport

use open Local of `./local`

document (|
  title = {\SATySFi; 0.0.xユーザのための0.1.0-alpha.1手引き},
  author = {Takashi Suwa},
|) '<
  +chapter{はじめに}<
    +p{
      \SATySFi; 0.1.0-alpha.1が1–2ヵ月程度の近いうちにリリースできそうな形になってきたので，
      既に\SATySFi; 0.0.xに馴染んでいるユーザの方々向けに，
      0.0.xと比べてどのような非互換な変更が入るかを共有したいと思います．
    }
  >
  +chapter{言語設計上の非互換な変化}<
    +section{具象構文上の差異}<
      +subsection{リストとレコードの区切り記号}<
        +p{
          リストおよびレコードのリテラルでは，
          区切り記号としてセミコロンではなくコンマが使われるようになります\footnote{
            もともとセミコロンを区切り記号にしていたのは，
            単にOCamlの具象構文に追従したためでした．
            OCamlの場合はタプルに括弧が必須ではなく
            `a, b` と書いただけでタプル扱いとなる構文を採用しており，
            それゆえ `[a, b; c, d]` のようにタプルのリストが簡単に書けるなどの
            或る種の利点らしきものがありましたが，
            \SATySFi;では却ってわかりづらくなることを避けるために
            タプルは括弧を必須としており，
            特にコンマとセミコロンを区別する動機がないため，
            この機会にコンマに揃えることにしました．
          }：

          \compare(|
            old = ```
              [3; 1; 4; 1; 5; 9; 2]
            ```,
            new = ```
              [3, 1, 4, 1, 5, 9, 2]
            ```,
          |);

          \compare(|
            old = ```
              (| foo = 42; bar = `qux` |)
            ```,
            new = ```
              (| foo = 42, bar = `qux` |)
            ```,
          |);

          従来末尾セミコロンが許容されていたのと同様に，いずれも末尾コンマが許容されます．
        }
      >
      +subsection{match式}<
        +p{
          match式は，match式が入れ子になった際のいわゆる「ぶら下がりmatch」による構文上の曖昧性を解消するために，
          `end` というトークンを最後につける構文に変更されます：

          \compare(|
            old = ```
              match opt1 with
              | None ->
                  ( match opt2 with
                    | None     -> y
                    | Some(x2) -> f x2
                  )
              | Some(x1) ->
                  f x1
            ```,
            new = ```
              match opt1 with
              | None ->
                  match opt2 with
                  | None     -> y
                  | Some(x2) -> f x2
                  end
              | Some(x1) ->
                  f x
              end
            ```,
          |);
        }
      >
      +subsection{let open}<
        +p{
          OCamlに倣い，ローカルなモジュールのオープンは先頭に `let` をつけます：

          \compare(|
            old = ```
              open Nat in
              succ (succ zero)
            ```,
            new = ```
              let open Nat in
              succ (succ zero)
            ```,
          |);
        }
      >
      +subsection{型コンストラクタの前置}<
        +p{
          OCamlやStandard MLなどとは異なり，
          型コンストラクタは型引数に対して前置するようになります：

          \compare(|
            old = ```
              type 'a foo =
                | Bar of int list
                | Qux
            ```,
            new = ```
              type foo 'a =
                | Bar of list int
                | Qux
            ```,
          |);

          これは主に式の函数適用が函数→引数の順であるのと揃えることを意図しています．
        }
      >
    >
    +section{ソースファイルとトップレベル定義}<
      +p{
        0.1.0-alpha.1のドキュメントファイル（拡張子が `.saty` の入力ファイル）は
        0.0.xとほぼ変わらず，構文としては（プリアンブルの後に）式をひとつ書けるファイルです：

        \compare(|
          old = ```
            @require: stdjareport

            document (|
              title = {文書例};
              author = {Takashi Suwa};
            |) '<
              +section{章題}<
                +p{0.0.xの文書の例です．}
              >
            >
          ```,
          new = ```
            use package open StdJaReport

            document (|
              title = {文書例},
              author = {Takashi Suwa},
            |) '<
              +section{章題}<
                +p{
                  0.1.0-alpha.1での文書の例です．
                  プリアンブル部分を除いてはほぼ変わりませんね．
                }
              >
            >
          ```,
        |);

        一方で，ライブラリやローカルな定義を集めたソースファイル（拡張子が `.satyh` や `.satyg` などのもの）は
        書き方がわりと変わります．1つのソースファイル中にはただ1つのモジュールの定義を書くように強制されます：

        \compare(|
          old = ```
            @require: list
            @require: option

            type foo = int

            let bar = 42

            let-rec show-list show-elem xs =
              List.fold-left-adjacent (fun s x prev-opt next-opt -> (
                s ^ show-elem x ^
                  (if Option.is-none next-opt then ` ` else `, `#)
              )) ` ` xs

            let-inline ctx \show-ints xs =
              read-inline ctx (embed-string (show-list arabic xs))
          ```,
          new = ```
            use package open Stdlib

            module Util = struct
              type foo = int

              val bar = 42

              val rec show-list show-elem xs =
                List.fold-adjacent (fun s x prev-opt next-opt -> (
                  s ^ show-elem x ^
                    (if Option.is-none next-opt then ` ` else `, `#)
                )) ` ` xs

              val inline ctx \show-ints xs =
                read-inline ctx (embed-string (show-list arabic xs))
            end
          ```,
        |);

        したがってトップレベルの値の束縛は必ずモジュールのメンバとなり，
        具象構文としても先頭のトークンを `let` ではなく `val` で書くように変更されます．
        もともと `let-rec` と書いていたものは `val rec` に，
        `let-mutable` と書いていたものは `val mutable` に，
        `let-inline` と書いていたものは `val inline` に，
        `let-block` と書いていたものは `val block` に，
        それぞれ変わります．
        ローカルな変数束縛の `let` は `let` のままですが，
        `let-rec` と `let-mutable` はやはり `let rec`，`let mutable` と2トークンになります．
      }
    >
    +section{型つけの変更}<
      +subsection{page型の廃止}<
        +p{
          0.0.xには用紙サイズ指定のために `A4Paper` などのコンストラクタをもつ `page` 型がありましたが，
          これは `length * length` で事足りるため廃止します．
          代わりに，標準ライブラリに `Stdlib.PaperSize` というモジュールが追加され，
          プリアンブルに `use package open Stdlib` と記載すれば `PaperSize.a4` などが使えるようになります．
        }
      >
      +subsection{graphics型の変更}<
        +p{
          従来，グラフィックス相当のデータは `graphics list` 型の式で構築されていました．
          しかし，`graphics` 型と `graphics list` 型との区別はせいぜい実装の都合でしかなく，
          いちいちリストなのか単一なのかをユーザ側で意識せねばならないのは不自然でした．
          そこで，0.1.0-alpha.1 では
          `unite-graphics : list graphics -> graphics`
          というプリミティブによってリストが（後方の要素ほど紙面上で後に描画されるものとして）
          単一のグラフィックスへと潰せるようにし，
          `graphics` 型のみがグラフィックスのデータを扱う主軸の型であるように改めました．
          これに伴い，例えばプリミティブ `inline-graphics` の型も

          `length -> length -> length -> (point -> graphics list) -> inline-boxes`

          から

          `length -> length -> length -> (point -> graphics) -> inline-boxes`

          に改まりました．
        }
      >
      +subsection{math-char-class型の拡張}<
        +p{
          数式の文字クラスを表す `math-char-class` 型に，
          サンセリフ体とタイプライタ体に関する5つのコンストラクタ
          `MathSansSerif`，
          `MathBoldSansSerif`，
          `MathItalicSansSerif`，
          `MathBoldItalicSansSerif`，
          `MathTypewriter`
          が追加されます．
          これにより，Unicodeコードポイントが与えられている
          数式文字クラスはひととおり揃いました．
        }
      >
      +subsection{数式コマンドの意味論}<
      >
      +subsection{型註釈}<
      >
    >
    +section{レコード型の多相性}<
    >
    +section{モジュールシステム}<
    >
    +section{多段階計算}<
    >
  >
  +chapter{エコシステムSaphe}<
  >
  +chapter{テスト機構}<
  >
  +chapter{今後入りそうな変更}<
  >
>
